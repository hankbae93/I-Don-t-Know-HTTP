# IP (Internet Protocol address)

1.  지정한 IP주소에 데이터 전달

2.  패킷(Packet) 단위로 데이터 전달

    - 패킷 구조

      출발지 IP , 목적지 IP, 기타 + 전송할 데이터

3.  클라이언트가 인터넷에 패킷을 던지면 중간 노드들이 서로 목적지 ip(서버)를 물어보면서 패킷을 전달한다.

    - 클라이언트가 서버에게 닿은 노드 경로들과 서버가 클라이언트가에게 보내는 패킷 노드 경로는 다를 수 있다.

4.  한계

        1. 비연결성
        패킷을 받을 대상이 없거나 서비스 불능(서버가 꺼져있다던가) 상태여도 패킷 전송

        2. 비신뢰성
            ㄱ. 중간에 패킷이 유실됐을 때 클라이언트는 알 수가 없다.

            ㄴ. 패킷이 순서대로 안오면?
            - 패킷의 경우 최대 1500byte까지라고 하는데 만약 15000byte의 메세지가 있다하면 10개로 나누어서 보낸다.
             그러나 이 패킷들은 각자 경로가 다 다를 수 있고 막상 서버가 다 받아도 어떤 순서로 받아야하는지 알 수가 없다. )

        3. 프로그램 구분 (같은 IP에서 통신하는 애플리케이션이 두개 이상이라면?)
        - 예를 들어 유투브의 영상 데이터를 보냈을 때 그걸 받는 IP는 이것이 어디에 들어가는 것인지 알 수 없다.
         IP는 하나이기 때문에 멜론 / 유투브 / 메세지 세개를 보내면 목적지에는 잘 도착하지만 막상 그 목적지 IP는 패킷으로 무엇을 해야되는지도 알 수 없다.

## 인터넷 프로토콜 스택 4계층

---

    1. 애플리케이션 계층 - HTTP, FTP

    2. 전송 계층 - TCP, UDP
    3. 인터넷 계층 - IP

    4. 네트워크 인터페이스 계층


    애플리케이션  - 클라이언트가 SOCKET 라이브러리로 메세지를 보냇다. 내용은 "HELLO"

    OS - TCP 정보를 생성해서 메세지를 감싼다
       - 그다음 IP 패킷을 생성해서 TCP + 메세지를 감싼다.

    네트워크 인터페이스 - Ethernet frame이라는 것으로 한번 더 감싸고 패킷을 전송한다.

# TCP/IP (Transmission Control Protocol)

1. 전 글에서 봤듰이 TCP로 메세지를 감쌀 때 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증 정보 등등을 추가한다.

   - 전송제어도 같이 보내기 때문에 밑에 항목들이 가능해진다.

2. 전송 제어 프로토콜

   - 연결지향 (3way handshake)

     일단 목적지 IP가 연결이 되어있는지 받을 수 있는 지 확인하는 신호를 먼저 보낸다.

   - 데이터 전달 보증

   - 순서 보장

   - 신뢰할 수 있는 프로토콜

<br />

## TCP/IP - 연결지향 (3way handshake)

---

SYN : 접속 요청
ACK: 요청 수락

클라이언트가 서버에게 메세지를 보낼 때 총 3번의 과정을 가진다.

1. 클라이언트 => SYN 전송 => 서버 (받을 수 있니?)

2. 클라이언트 <= SYN + ACK 전송 <= 서버 (받을 수 있다. 보내라)

3. 클라이언트 => ACK 전송 => 서버 (OK. 진짜 보낸다)

   - 요즘은 최적화되서 이 과정에서 데이타도 같이 보낸다고 한다.

4. 클라이언트 => DATA 전송 => 서버

이런 과정에서 클라이언트와 서버는 서로 신뢰가능해진다. 추가적으로 알아야 할 것은 실제로 연결이 되었다기보다는 서로 논리적으로 확인하는 과정이다. 중간의 노드들은 아무것도 모른다.

## TCP/IP - 데이터 전달 보증

---

클라이언트가 서버에게 데이터를 보내면 서버는 데이터를 잘 받았는지의 여부를 다시 보내준다

## TCP/IP - 순서 보장

---

1. 클라이언트 - [ 패킷 1 , 패킷 2, 패킷 3 ] 순서로 전송

2. 서버 - [ 패킷 1 , 패킷 3 ??, 패킷 2 ] 로 전달 받음
   - 여기서 서버는 패킷 1 다음이 2가 아닌 것이 와서 잘못됐다고 판단하고
     패킷 3, 패킷 2를 버리고 클라이언트에게 2번부터 다시 보내라고 한다

# UDP (User Datagram Protocol)

TCP 내용을 보다 보면 3 way handshake나 순서 보장 등등 서로 보내야되는 신호가 너무 많아서 시간이 많이 걸린다.
유투브 영상 데이터만 생각하더라도 패킷 수만개를 보내야되는 상황에서 곱하기 3이라고 생각하면 그 시간은 더 어마어마할 것이다.
UDP는 그런 단점들 때문에 이런 검증 과정을 버리고 빠른 전송을 위해 태어났다.

1. 연결 지향 X

2. 데이터 전달 보증 X

3. 순서 보장 X

4. 하지만 단순하고 빠름

5. IP와 거의 같다. + PORT + 체크섬 정도만 추가

6. 애플리케이션에서 따로 추가 작업이 필요하긴 하다.

7. 현재는 TCP가 대부분이지만 UDP가 각광받는 이유는 HTTP3가 3 way handshake 기능을 최적화해서 나온다는 얘기가 잇어서다.

# PORT (항구)

한 IP가 여러 IP들과 연결해야 된다면?

1. 같은 IP 내에서 프로세스를 구분한다.

   - TCP/IP 패킷을 보내면 목적지 IP와 그 IP 내의 PORT까지 같이 보낸다.
   - 그러면 서버는 그 PORT에 패킷 데이터를 사용한다.
   - 멜론과 음악 데이터를 통신하고 유투브와 영상데이터를 통신하는 등의 과정이 한 IP내에서 가능해진다.

2. 범위
   - 0 ~ 65535 할당 가능
   - 0 ~ 1023: 잘 알려진 포트 (사용하지 않는 것 추천)
     ㄱ. FTP - 20, 21
     ㄱ. TELNET - 23
     ㄱ. HTTP - 80
     ㄱ. HTTPS - 443

목적지 IP의 PC를 아파트라 하면 PORT는 그 아파트내 몇동 몇호

# DNS (Domain Name System)

IP는 기억하기 어렵다. 200.200.200.2 ???

IP는 변경될 수 있다.

- 사용자가 실제 IP주소를 모르거나 해당 도메인의 IP가 변경되었어도 도메인 이름만 알면 언제든지 접속할 수 있다.

1. DNS는 전화번호부같은 서버를 제공해준다.

2. 도메인 명을 등록하면 그 해당하는 IP주소로 변환

3. DNS 사용

   - 클라이언트에서 도메인명을 DNS 서버에 보낸다. "www.naver.com"

   - DNS 서버는 응답으로 IP 주소를 보내준다.

   - 클라이언트는 그 IP주소로 접속한다.

   - 만약 네이버의 IP가 바뀌면 새로 DNS에 등록하면 된다.

# 🍳 IP (내부 IP / 공인 IP)
