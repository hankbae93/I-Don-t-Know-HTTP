# IP (Internet Protocol address)

1.  지정한 IP주소에 데이터 전달

2.  패킷(Packet) 단위로 데이터 전달

    - 패킷 구조

      출발지 IP , 목적지 IP, 기타 + 전송할 데이터

3.  클라이언트가 인터넷에 패킷을 던지면 중간 노드들이 서로 목적지 ip(서버)를 물어보면서 패킷을 전달한다.

    - 클라이언트가 서버에게 닿은 노드 경로들과 서버가 클라이언트가에게 보내는 패킷 노드 경로는 다를 수 있다.

4.  한계

        1. 비연결성
        패킷을 받을 대상이 없거나 서비스 불능(서버가 꺼져있다던가) 상태여도 패킷 전송

        2. 비신뢰성
            ㄱ. 중간에 패킷이 유실됐을 때 클라이언트는 알 수가 없다.

            ㄴ. 패킷이 순서대로 안오면?
            - 패킷의 경우 최대 1500byte까지라고 하는데 만약 15000byte의 메세지가 있다하면 10개로 나누어서 보낸다.
             그러나 이 패킷들은 각자 경로가 다 다를 수 있고 막상 서버가 다 받아도 어떤 순서로 받아야하는지 알 수가 없다. )

        3. 프로그램 구분 (같은 IP에서 통신하는 애플리케이션이 두개 이상이라면?)
        - 예를 들어 유투브의 영상 데이터를 보냈을 때 그걸 받는 IP는 이것이 어디에 들어가는 것인지 알 수 없다.

         IP는 하나이기 때문에 멜론 / 유투브 / 메세지 세개를 보내면 목적지에는 잘 도착하지만

         막상 그 목적지 IP는 패킷으로 무엇을 해야되는지도 알 수 없다.

## 인터넷 프로토콜 스택 4계층

---

    1. 애플리케이션 계층 - HTTP, FTP

    2. 전송 계층 - TCP, UDP
    3. 인터넷 계층 - IP

    4. 네트워크 인터페이스 계층


    애플리케이션  - 클라이언트가 SOCKET 라이브러리로 메세지를 보냇다. 내용은 "HELLO"

    OS - TCP 정보를 생성해서 메세지를 감싼다
       - 그다음 IP 패킷을 생성해서 TCP + 메세지를 감싼다.

    네트워크 인터페이스 - Ethernet frame이라는 것으로 한번 더 감싸고 패킷을 전송한다.

# TCP/IP (Transmission Control Protocol)

1. 전 글에서 봤듰이 TCP로 메세지를 감쌀 때 출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증 정보 등등을 추가한다.

   - 전송제어도 같이 보내기 때문에 밑에 항목들이 가능해진다.

2. 전송 제어 프로토콜

   - 연결지향 (3way handshake)

     일단 목적지 IP가 연결이 되어있는지 받을 수 있는 지 확인하는 신호를 먼저 보낸다.

   - 데이터 전달 보증

   - 순서 보장

   - 신뢰할 수 있는 프로토콜

<br />

## TCP/IP - 연결지향 (3way handshake)

---

SYN : 접속 요청
ACK: 요청 수락

클라이언트가 서버에게 메세지를 보낼 때 총 3번의 과정을 가진다.

1. 클라이언트 => SYN 전송 => 서버 (받을 수 있니?)

2. 클라이언트 <= SYN + ACK 전송 <= 서버 (받을 수 있다. 보내라)

3. 클라이언트 => ACK 전송 => 서버 (OK. 진짜 보낸다)

   - 요즘은 최적화되서 이 과정에서 데이타도 같이 보낸다고 한다.

4. 클라이언트 => DATA 전송 => 서버

이런 과정에서 클라이언트와 서버는 서로 신뢰가능해진다.

추가적으로 알아야 할 것은 실제로 연결이 되었다기보다는 서로 논리적으로 확인하는 과정이다.

중간의 노드들은 아무것도 모른다.

## TCP/IP - 데이터 전달 보증

---

클라이언트가 서버에게 데이터를 보내면 서버는 데이터를 잘 받았는지의 여부를 다시 보내준다

## TCP/IP - 순서 보장

---

1. 클라이언트 - [ 패킷 1 , 패킷 2, 패킷 3 ] 순서로 전송

2. 서버 - [ 패킷 1 , 패킷 3 ??, 패킷 2 ] 로 전달 받음
   - 여기서 서버는 패킷 1 다음이 2가 아닌 것이 와서 잘못됐다고 판단하고
     패킷 3, 패킷 2를 버리고 클라이언트에게 2번부터 다시 보내라고 한다

# UDP (User Datagram Protocol)

TCP 내용을 보다 보면 3 way handshake나 순서 보장 등등 서로 보내야되는 신호가 너무 많아서 시간이 많이 걸린다.

유투브 영상 데이터만 생각하더라도 패킷 수만개를 보내야되는 상황에서 곱하기 3이라고 생각하면 그 시간은 더 어마어마할 것이다.

UDP는 그런 단점들 때문에 이런 검증 과정을 버리고 빠른 전송을 위해 태어났다.

1. 연결 지향 X

2. 데이터 전달 보증 X

3. 순서 보장 X

4. 하지만 단순하고 빠름

5. IP와 거의 같다. + PORT + 체크섬 정도만 추가

6. 애플리케이션에서 따로 추가 작업이 필요하긴 하다.

7. 현재는 TCP가 대부분이지만 UDP가 각광받는 이유는 HTTP3가 3 way handshake 기능을 최적화해서 나온다는 얘기가 잇어서다.

# PORT (항구)

한 IP가 여러 IP들과 연결해야 된다면?

1. 같은 IP 내에서 프로세스를 구분한다.

   - TCP/IP 패킷을 보내면 목적지 IP와 그 IP 내의 PORT까지 같이 보낸다.

   - 그러면 서버는 그 PORT에 패킷 데이터를 사용한다.

   - 멜론과 음악 데이터를 통신하고 유투브와 영상데이터를 통신하는 등의 과정이 한 IP내에서 가능해진다.

2. 범위

   - 0 ~ 65535 할당 가능
   - 0 ~ 1023: 잘 알려진 포트 (사용하지 않는 것 추천)

     ㄱ. FTP - 20, 21

     ㄴ. TELNET - 23

     ㄷ. HTTP - 80

     ㄹ. HTTPS - 443

목적지 IP의 PC를 아파트라 하면 PORT는 그 아파트내 몇동 몇호

# DNS (Domain Name System)

IP는 기억하기 어렵다. 200.200.200.2 ???

IP는 변경될 수 있다.

- 사용자가 실제 IP주소를 모르거나 해당 도메인의 IP가 변경되었어도 도메인 이름만 알면 언제든지 접속할 수 있다.

1. DNS는 전화번호부같은 서버를 제공해준다.

2. 도메인 명을 등록하면 그 해당하는 IP주소로 변환

3. DNS 사용

   - 클라이언트에서 도메인명을 DNS 서버에 보낸다. "www.naver.com"

   - DNS 서버는 응답으로 IP 주소를 보내준다.

   - 클라이언트는 그 IP주소로 접속한다.

   - 만약 네이버의 IP가 바뀌면 새로 DNS에 등록하면 된다.

# 🍳 IP (내부 IP / 공인 IP)

https://velog.io/@hidaehyunlee/%EA%B3%B5%EC%9D%B8Public-%EC%82%AC%EC%84%A4Private-IP%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90

내부 IP (사설 ip): PC 내에만 존재하며 인터넷에 직접 접근이 불가능하다.

- IP 프로토콜은 내부 IP끼리의 통신도 포함한다.

- cmd의 ipconfig에 나오는 ip도 내부 ip를 의미한다.

- 라우터에 연결된 개인 PC는 내부 ip를 각각 할당받아 접속할 수 있게 된다.

<br/>

공인 IP: ISP(인터넷 서비스 공급자)가 제공하는 IP 주소

- 전세계에서 유일한 IP 주소이며 흔히 SKT, KT 인터넷 같은 곳에서 ISP에 받아온 공인IP를 받아와 제공한다.

- https://ip.pe.kr/ 에서 현재 사용중인 공인 ip를 확인 가능

집에서 모뎀 하나(최초의 공인 IP 경로)를 설치하면 그 포트에 랜선을 꽂은 기억이 있을 것이다.

우리 PC에 할당된 내부 IP에서 공인 IP에 접근해 인터넷을 연결 할 수 있다.

         INTERNET => 공인 IP (라우터) -> 사설 IP: 192.168.0.100

                                     -> 사설 IP: 192.168.0.101

                  => 공인 IP (라우터) -> 사설 IP: 192.168.1.100

# URI (Uniform Resource Identifier)

- 단어 뜻

      Uniform: 리소스 식별하는 통일된 방식

      Resource: 자원, URI로 식별할 수 있는 모든 것

      Identifier : 다른 항목과 구분하는데 필요한 정보

- URI는 locator 또는 name 또는 둘 다 추가로 분류 될 수 있다.

  => URI = URL + URN

- URL : Resource Locator 리소스의 위치

- URN : Resource Name 리소스의 이름

  ㄱ. 위치는 변할 수 있지만 이름은 변하지 않음

  ㄴ. 그러나 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화되지 않음

<br/>

## URL 전체 문법

      scheme:// [userinfo@] host [:port] [/path] [?query] [#fragment]

예시: https://www.google.com:443/search?q=hello&hl=ko

1. scheme://

   - 프로토콜 사용

   - 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 (http, https, ftp 등등)

2. [userinfo@]

   - URL에 사용자 정보 포함해서 인증

   - 거의 사용하지 않음

3. host

   - 호스트명 도메인명 또는 IP 주소 직접 입력 가능

4. [:port]

   - http는 80 port , https는 443 port를 주로 사용하며 포트는 생략가능

5. [/path]

   - 리소스 경로(path), 계층적 구조

   - /home/file1.jpg, /members, /news/100

6. [?query]

   - key = value 형태

   - ?로 시작, &로 추가 가능

   - query parameter, query string으로 불림

   - 숫자 타입을 넣어도 문자로 넘어가기 때문에 query string으로도 부른다.

   - 배열의 경우 ?arr=1&arr=2&arr=3 처럼 작성하면 arr = [1,2,3] 으로 서버에서 인식한다.

7. [#fragment]

   - 예시: https://www.naver.com/render/index.html/#getting-started

   - html 내부 북마크 등에 사용되며 서버에 전송하는 정보는 아니다.

<br/>

# 웹 브라우저 요청 흐름

1.  HTTP 요청 메시지 구조

         GET /search?q=hello HTTP/1.1
         HOST: www.google.com

2.  URL을 크롬 브라우저에 입력해서 접속할 때 상황

         애플리케이션 - 웹 브라우저          => 웹 브라우저가 HTTP 메세지 생성

                     - SOCEKT 라이브러리    => SOCKET 라이브러리 통해 TCP/IP로 데이터 전달

         OS          - TCP/IP              => TCP 정보를 생성해서 HTTP 메세지를 감싼다
                                           => 그다음 IP 패킷을 생성해서 TCP + HTTP 메세지를 감싼다.

         네트워크     - 랜카드              => 패킷을 전송한다.

         서버에서는 패킷이 도착하면 HTTP 응답 메세지를 클라이언트에게 보내준다.
         그리고 우리는 그 HTTP응답메세지에 들어있는 html 파일을 볼 수 있다.
